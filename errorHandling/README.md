# Error handling

에러는 언제 어디서나 발생한다. 
고가용성이 99.9999%라 해도 1년에 10초 정도는 고장이다. 

에러 핸들링은 두가지 방식이 있다.
1. 빠르게 프로그램을 죽이는 방식 => panic
2. 에러를 처리해서 프로그램을 지속시키는 방식 => return error
 
하지만 에러, 개발 단계, 프로그램 성격마다 처리 방법이 다르다. 
중요한 시스템에서는 오류가 생겨도 죽지 않게 하는 것 처럼 
ex) 심장에 관련된 프로그램 => 프로그램이 죽으면 큰일난다. 


### 사용자 에러반환

두가지 방식을 사용한다.
- fmt.Errorf(formatter string, ...interface{}) error
- error.New(text string) error 


### error의 타입
```
type error interface{
    Error() string
}
```
위 인터페이스만 맞추면 에러를 만들 수 있다. 


### 뜯어보기
스스로 분석하는 역량을 키우기 위해서 필요하다고 생각해서 작성한다. 
```
scanner := bufio.NewScanner(strings.NewReader(str))
```

bufio 패키지는 io.Reader를 인자로 받고, Scanner객체를 반환한다. 
```
func NewScanner(r io.Reader) *Scanner
```

그런데 io.Reader가 무엇일까?

io.Reader는 Read()라는 기능을 갖는 인터페이스다. 
```
type Reader interface {
	Read(p []byte) (n int, err error)
}
```
즉 strings.NewReader는 io.Reader라는 인터페이스를 사용하기 위해서 Read()라는 기능을 갖는 객체를 반환하는 것이다. 


### 패닉
처리하기 힘든 에러를 만났을 때 프로그램을 조기 종료하는 방법
빠르게 종료시켜서 오류를 해결하기 위해 사용 

panic이 일어나면 프로그램이 죽으면서 어디서 죽었는지 바로 보인다. 
문제를 빠르게 파악하고 고칠 수 있다. 

최대한 죽지 않는 서비스의 경우에는 panic을 쓰지 않는 것이 좋다. 
panic을 사용하는 경우 복구를 해야할 필요가 있다. 

패닉이 발생했을 때는 에러는 전파되는데
콜 스택 역순으로 전파된다.

다음과 같은 순으로 함수를 호출한다고 했을 때 
main() => f() => g() => h()

g() => f() => main() 순으로 
복구가 되었는지 확인한다. 

복구는 recover로 한다. 

### recover 
주로 recover는 defer와 사용된다. 

하지만 복구는 사용하지 않는게 좋다. 

복구가 발생했다는 것은 panic이 발생했다는 것이므로 이미 에러가 있다는 것이다. 


### Go는 SEH를 지원하지 않는다.
SEH는 try~ catch~ 구문을 의미한다. 
사용하지 않는 이유는 다음과 같다. 
- 성능 문제: 정상으로 동작하든, 비정상으로 동작하든 SEH를 지원하기 위해 사용하므로 성능 손해이다. 
- 에러를 등한시 한다는 문제: 최상위 클래스인 Exception을 이용해서 작성하는 경우 어떤 에러가 발생했는지도 모르고 지나갈 수 있기 때문이다. 이는 에러처리를 등한시하게 된다.

### 에러처리는 매우 중요하다.
에러처리는 귀찮지만 매우 중요하다. 

함수에서 반환되는 에러를 제대로 처리해야한다.
(_로 무시하지 말자)
에러는 조기에 발견하여 더 큰 문제를 미연에 방지해야 한다. 

